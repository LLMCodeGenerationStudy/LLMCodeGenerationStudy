# extract the function body from LLM's output
import json
import os
import tempfile
import re
import sys
import io
import traceback
import subprocess

def find_function_names(code):
    """
        obtain the function signature
    """
    pattern = r"\bdef\s+(\w+)\s*\("
    matches = re.findall(pattern, code)
    
    return matches


def process_answer(text):
    """
        extract the function body
    """
    text = text.strip('[PYTHON]').strip('[/PYTHON]')
    
    if '```' in text:
        blocks = re.findall(r'```(.*?)```', text, re.DOTALL)
        if len(blocks) == 0:
            text = text.split('```')[1]  # fall back to default strategy
        else:
            text = blocks[0]  # fetch the first code block
            if not text.startswith('\n'):  # in case starting with ```python
                text = text[max(text.find('\n') + 1, 0):]
    else:
        match = re.search(r'Here(.*?)\n', text)
        if match:
            text = re.sub('Here(.*?)\n', '', text, count=1)
        match = re.search(r'One approach(.*?)\n', text)
        if match:
            text = re.sub('One approach(.*?)\n', '', text, count=1)

    if text.startswith("markdown"):
        text = text[8:]
    if text.endswith('</s>'):
        return text[:-4]
    else:
        return text


def filter_unit_test(datas):
    """
        filter out the unit test samples generated by LLM
    """
    a = "Below is a Python script with a self-contained function that solves the problem and passes corresponding tests:"
    b = "Below are tests for"
    c = "Below are some tests"
    d = "def test"
    ff = "# Test"
    gg = "# Example"

    for item in datas:
        solution = item['solution']
        if ff in solution:
            solution = solution.split(ff)[0]
        if gg in solution:
            solution = solution.split(gg)[0]

        item['solution'] = solution



# json file of LLM's output
file_name = './rwpb-phi3.json'

with open(file_name, 'r') as f:
    datas = json.load(f)
    filter_unit_test(datas)

with open(file_name, 'w') as f:
    json.dump(datas, f, indent=1, ensure_ascii=False)
